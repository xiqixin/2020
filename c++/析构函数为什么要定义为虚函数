基类的析构函数为什么必须是虚函数呢？
    我们都知道，想要回收一个对象申请的资源，那么就需要调用析构函数。
虽然我们没有显示地调用析构函数，但是编译器都会默认地为我们执行析构函数。
那么执行完 BaseClass *base = new BaseClass(); 
当我们执行 delete base时，会调用析构函数为我们释放资源。
而我们执行BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数
不是虚函数的时候，delete sub 对象的时候，只会释放BaseClass 基类申请的
资源，而不是释放SubClass派生类的资源。原因如下：
   基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚构函数是
动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态
绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，
而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会
造成内存泄漏，这是相当危险的：如果系统中有大量的派生类对象被这样创建和销毁，
就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。
   当然，如果在派生类中没有动态申请有资源的时候，是不会造成内存泄漏的。而当
派生类对象的析构函数中有内存需要回收，并且在编程过程中采用了基类指针指向派生
类对象，如为了实现多态，并且通过基类指针将对象销毁，这时，就会因为基类的析构
函数为非虚函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。
因此，为了防止这种情况下的内存泄漏的发生，最后将基类的析构函数写成virtual虚析构函数。   
